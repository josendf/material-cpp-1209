/**
 * @file   hmac.hpp
 * @author jedf
 * @date   Thu Aug 16 15:49:35 2012
 *
 * @brief  MAC Access Authentication helpers.
 *         As IETF Draft
 *         http://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01
 */

#pragma once
#ifndef HTPARSE_AUTH_MAC_HPP_
#define HTPARSE_AUTH_MAC_HPP_
#include <locale>
#include <sstream>
#include <string>
#include <map>
#include <ext/boost/spirit.hpp>
#include <ext/boost/optional.hpp>
#include <ext/boost/lexical_cast.hpp>
#include <ext/boost/locale.hpp>

namespace htparse { namespace auth { namespace mac {
using std::string;
using std::stringstream;
using std::pair;
using boost::optional;

/** The MAC Authorization request header
 */
struct header
{
  /// The MAC key identifier. Required.
  string id_;

  /// The request timestamp. Required.
  long long ts_;

  /// A unique string generated by the client. Required.
  string nonce_;

  /// A string used to include additional information. Optional.
  string ext_;

  /// The HTTP request MAC as described. Required.
  string mac_;

  header():
    ts_(0) {}

  template <class TDict>
  static
  optional<header> from_dict(const TDict& dict)
  {
    using boost::lexical_cast;
    using boost::bad_lexical_cast;
    typedef typename TDict::const_iterator iter_type;

    header hdr;

    const iter_type end = dict.end();

    // The MAC key identifier. Required.
    iter_type pos = dict.find("id");
    if(pos != end) hdr.id_ = pos->second;

    // The request timestamp. Required.
    pos = dict.find("ts");
    if(pos != end)
    {
      try { hdr.ts_ = lexical_cast<long long>(pos->second); }
      catch(bad_lexical_cast&) { hdr.ts_ = 0; }
    }

    // A unique string generated by the client. Required.
    pos = dict.find("nonce");
    if(pos != end) hdr.nonce_ = pos->second;

    // A string used to include additional information. Optional.
    pos = dict.find("ext");
    if(pos != end) hdr.ext_ = pos->second;

    // The HTTP request MAC. Required.
    pos = dict.find("mac");
    if(pos != end) hdr.mac_ = pos->second;

    if(hdr.id_.empty()    ||
       hdr.ts_ < 1        ||
       hdr.nonce_.empty() ||
       hdr.mac_.empty())
       return optional<header>();

    return optional<header>(hdr);
  }

  template<class TStm>
  TStm& show(TStm& buf) const
  {
    buf << "id:" << id_
        << " ts:" << ts_
        << " nonce:" << nonce_
        << " ext:" << ext_
        << " mac:" << mac_;
    return buf;
  }

};

namespace detail {

/** A simple key-value pair list parser.
 */
template <class TIter>
struct basic_key_value_parser:
    boost::spirit::qi::grammar<TIter,
                               std::map<string, string>(),
                               boost::spirit::ascii::space_type>
{
  typedef TIter iter_type;
  typedef std::map<string, string> result_type;
  typedef std::pair<string, string> pair_type;
  typedef boost::spirit::ascii::space_type space_type;

  boost::spirit::qi::rule<iter_type, result_type(), space_type> start_;
  boost::spirit::qi::rule<iter_type, pair_type(), space_type> pair_;
  boost::spirit::qi::rule<iter_type, string(), space_type> key_;
  boost::spirit::qi::rule<iter_type, string(), space_type> quoted_;
  boost::spirit::qi::rule<iter_type, string(), space_type> unquoted_;

  basic_key_value_parser(const string& prefix,
                         const char separator,
                         const int max_key_length,
                         const int max_value_length):
    basic_key_value_parser::base_type(start_)
  {
     using boost::spirit::qi::lit;
     using boost::spirit::qi::lexeme;
     using boost::spirit::qi::ascii::char_;
     using boost::spirit::qi::repeat;

     start_ = lit(prefix) >> pair_ >> +(lit(separator) >> pair_);

     pair_ = key_ >> '=' >> (quoted_ | unquoted_);

     key_ = repeat(1, max_key_length)[char_("a-zA-Z0-9_")];

     quoted_ = lexeme['"' >> repeat(0, max_value_length)[(char_ - '"')] >> '"'];

     unquoted_ = repeat(1, max_value_length)[char_("a-zA-Z0-9_")];
  }
};

} // namespace detail

/** Parses the MAC Authorization request header.
 *
 * Authorization: MAC id="h480djs93hd8",
 *                    ts="1336363200",
 *                    nonce="dj83hs9s",
 *                    ext="abc",
 *                    mac="6T3zZzy2Emppni6bzL7kdRxUWL4="
 *
 */
template <class TStr>
class basic_header_parser
{
public:
  typedef TStr string_type;
  typedef typename string_type::const_iterator iter_type;
  typedef detail::basic_key_value_parser<iter_type> parser_type;

private:
  parser_type parser_;

public:
  basic_header_parser():
    parser_("MAC", ',', 256, 1024) {}

  optional<header> parse(const string_type& str) const
  {
    using boost::spirit::qi::phrase_parse;
    using boost::spirit::ascii::space;
    typedef typename parser_type::result_type result_type;

    result_type dict;
    iter_type beg = std::begin(str);
    const bool ret = phrase_parse(beg, std::end(str), parser_, space, dict);
    if(!ret)
      return optional<header>();
    return header::from_dict(dict);
  }
};
typedef basic_header_parser<string> header_parser;

/** Normalized Request String
 * The normalized request string is a consistent, reproducible
 * concatenation of several of the HTTP request elements into a single
 * string. By normalizing the request into a reproducible string, the
 * client and server can both calculate the request MAC over the exact
 * same value.
 */
template <class TChr>
class basic_norm_request
{
public:
  typedef std::basic_string<TChr> string_type;

private:
  /// The request timestamp.
  long long ts_;

  /// A unique string generated by the client.
  string_type nonce_;

  /// The HTTP request method in upper case.
  string_type method_;

  /// The HTTP request-URI.
  string_type uri_;

  /// The hostname included in the HTTP request using the "Host"
  /// request header field in lower case.
  string_type host_;

  /// The port included in the HTTP request using the "Host"
  /// request header field, or the default value for the scheme.
  int port_;

  /// A string used to include additional information. Optional.
  string_type ext_;

public:
  basic_norm_request():
    ts_(0),
    port_(0) {}

  basic_norm_request(const header& hdr,
                       const string& req_method,
                       const string& req_host,
                       const int req_port,
                       const string& req_uri):
    ts_(hdr.ts_),
    nonce_(hdr.nonce_),
    method_(req_method),
    uri_(req_uri),
    host_(req_host),
    port_(req_port),
    ext_(hdr.ext_) {}

  /// The request timestamp.
  long long ts() const {
    return ts_;
  }
  /// The request timestamp.
  long long& ts() {
    return ts_;
  }

  /// A unique string generated by the client.
  const string_type& nonce() const {
    return nonce_;
  }
  /// A unique string generated by the client.
  string_type& nonce() {
    return nonce_;
  }

  /// The HTTP request method in upper case.
  const string_type& method() const {
    return method_;
  }
  /// The HTTP request method in upper case.
  string_type& method() {
    return method_;
  }

  /// The HTTP request-URI.
  const string_type& uri() const {
    return uri_;
  }
  /// The HTTP request-URI.
  string_type& uri() {
    return uri_;
  }

  /// The hostname included in the HTTP request using the "Host"
  /// request header field in lower case.
  const string_type& host() const {
    return host_;
  }
  /// The hostname included in the HTTP request using the "Host"
  /// request header field in lower case.
  string_type& host() {
    return host_;
  }

  /// The port included in the HTTP request using the "Host"
  /// request header field, or the default value for the scheme.
  int port() const {
    return port_;
  }
  /// The port included in the HTTP request using the "Host"
  /// request header field, or the default value for the scheme.
  int& port() {
    return port_;
  }

  /// A string used to include additional information. Optional.
  const string_type& ext() const {
    return ext_;
  }
  /// A string used to include additional information. Optional.
  string_type& ext() {
    return ext_;
  }

  /** Constructs the normalized request string.
   *
   * The string is constructed by concatenating together, in order, the
   * following HTTP request elements, each followed by a new line
   * character (%x0A):
   *
   * 1.  The timestamp value calculated for the request.
   * 2.  The nonce value generated for the request.
   * 3.  The HTTP request method in upper case.  For example: "HEAD",
   *     "GET", "POST", etc.
   * 4.  The HTTP request-URI as defined by [RFC2616] section 5.1.2.
   * 5.  The hostname included in the HTTP request using the "Host"
   *     request header field in lower case.
   * 6.  The port as included in the HTTP request using the "Host" request
   *     header field.  If the header field does not include a port, the
   *     default value for the scheme MUST be used (e.g. 80 for HTTP and
   *     443 for HTTPS).
   * 7.  The value of the "ext" "Authorization" request header field
   *     attribute if one was included in the request, otherwise, an empty
   *     string.
   *
   * @return The normalized string.
   */
  string_type normalize() const
  {
    using boost::locale::generator;
    typedef std::basic_stringstream<TChr> stream_type;
    using boost::locale::to_upper;
    using boost::locale::to_lower;

    generator lgen;
    std::locale loc = lgen("en_US.UTF-8");

    stream_type buff;
    buff.imbue(loc);

    // Each element is followed by a new line character (x0A) including the
    // last element and even when an element value is an empty string.
    const char sep = '\x0A';
    buff
      << ts_ << sep
      << nonce_ << sep
      << to_upper(method_, loc) << sep
      << uri_ << sep
      << to_lower(host_, loc) << sep
      << port_ << sep
      << ext_ << sep
      ;

    return buff.str();
  }

  template<class TStm>
  TStm& show(TStm& stm) const
  {
    using boost::locale::generator;
    using boost::locale::to_upper;
    using boost::locale::to_lower;

    generator lgen;
    std::locale loc = lgen("en_US.UTF-8");
    stringstream buff;
    buff.imbue(loc);

    buff
      << "ts:" << ts_
      << " nonce:" << nonce_
      << " method:" << to_upper(method_, loc)
      << " uri:" << uri_
      << " host:" << to_lower(host_, loc)
      << " port:" << port_
      << " ext:" << ext_
      ;

    stm << buff.str();
    return stm;
  }

};
typedef basic_norm_request<char> norm_request;


}}}
#endif
